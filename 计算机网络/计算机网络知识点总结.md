<h2 align="center">计算机网络知识点总结</h2>
#### 1.TCP协议

**TCP首部**：源端口，目的端口，序列号，确认号，几种标志位（SYN、ACK、RST和FIN等），校验和，接收窗口等

**序列号和确认号**：序号是该报文段首字节的序号，不是报文段的序号

**超时重传**：超时等待时间必须大于该连接的**往返时间**（RTT，round-trip time），即从一个报文段发出到它被确认的时间，维持一个样本RTT的均值（因为网络情况会变化），通过一个加权算法计算出（rtt = x·rtt + (1-x)rtt_n）



---

#### 2.TCP三次握手与四次挥手

**TCP为什么需要3次握手**

- > [TCP为什么需要3次握手与4次挥手](https://blog.csdn.net/xifeijian/article/details/12777187)
  >
  > [TCP 为什么三次握手而不是两次握手（正解版）](https://blog.csdn.net/lengxiao1993/article/details/82771768)

  **为什么不能只是两次握手**，主要是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误，例如客户端发出一个TCP连接请求，但是由于网络延迟导致在

> [TCP建立连接为什么是三次握手，为什么不是两次或四次](https://blog.csdn.net/to_be_better/article/details/54885684)

> [系统调优你所不知道的TIME_WAIT和CLOSE_WAIT](https://zhuanlan.zhihu.com/p/40013724 )

---

#### 3. TCP的流量控制和拥塞控制

**MSS**(Maximum Segment Size，最大报文长度):MSS是TCP数据包每次能够传输的最大数据分段(不包含头部),收发双方协商通信时每一个报文段所能承载的最大数据长度，通常根据最初确定的由本地发送主机发送的最大链路层帧（即**最大传输单元**(Maximum Transmission Unit,MTU)）长度来确定。

**RWND**(Receiver Window,接收窗口):是TCP首部里的一个字段，用于指示接收方愿意接收的字节数量

**CWND**:(Congestion Window,拥塞窗口):发送方维持的一个变量，用于限制TCP发送方向网络中发送流量的速率

在一个发送方未被确认的数据量不会超过以上两个值中的最小值

> [TCP的流量控制和拥塞控制](https://blog.csdn.net/yechaodechuntian/article/details/25429143 )

**流量控制**：即不要让发送方的发送速率过快，导致接收方来不及接收，具体是通过控制滑动窗口的大小来调节发送方的窗口大小

**拥塞控制**：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载，拥塞控制是一个全局性的过程，具体有以下三种方法：

- **慢启动**和**拥塞避免**：

  **慢启动**：发送方不能一开始就发送大量数据到网络，而是应该由小到大逐渐增加发送窗口的大小，拥塞窗口的值以1个MSS开始，每经过一个传输轮次，拥塞窗口 cwnd 就加倍。为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢启动阈值：ssthresh状态变量，慢启动阈值ssthresh的用法如下：

  ​    当 cwnd < ssthresh 时，使用上述的慢启动算法。

  ​    当 cwnd > ssthresh 时，停止使用慢启动算法而改用拥塞避免算法。

  ​    当 cwnd = ssthresh 时，既可使用慢启动算法，也可使用拥塞控制避免算法。

  **拥塞避免**：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢启动算法的拥塞窗口增长速率缓慢得多。

  无论在慢启动阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），**就要把慢启动门限ssthresh设置为出现拥塞时的发送方窗口值的一半**（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢启动算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。

- **快重传**和**快恢复**：

  **快重传**：（如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢启动算法，同时把慢启动门限值ssthresh减半，这是不使用快重传的情况）快重传算法首先要求接收方**每收到一个失序的报文段后就立即发出重复确认**（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时才进行捎带确认，发送方只要一连收到**三个重复确认**就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器到期。

  **快恢复**：当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢启动门限ssthresh减半。这是为了预防网络发生拥塞，接下去**不执行慢启动算法**，由于发送方现在认为网络很可能没有发生拥塞，因此与慢启动不同之处是现在不执行慢启动算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢启动门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。

---

#### 4.TCP粘包/拆包问题

> [TCP粘包/拆包问题](https://www.cnblogs.com/wade-luffy/p/6165671.html)

TCP 协议是面向字节流的，所谓流，就是没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。

产生的原因有以下三点：

- 应用程序写入的数据大于或小于套接字缓冲区大小
- 进行MSS大小的TCP分段
- 以太网帧的payload大于MTU进行IP分片

解决方法：

- 消息定长，例如每个报文的大小为固定长度200字节
- 在包尾增加回车换行符进行分割，例如FTP协议
- 将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段
- 更复杂的应用层协议

---

#### .IP地址分类

​	IP地址 = 网络号+主机号，分为A、B、C三类及特殊地址D、E。

***

#### .ARP协议



***

#### .HTTP版本区别



---



